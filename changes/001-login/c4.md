# C4 Model — Autenticação por Login (001-login)

**Versão**: 1.0
**Data**: 2026-02-28

---

## Nível 1 — Contexto do Sistema

*Quem usa o sistema e com quais sistemas externos ele interage.*

```mermaid
C4Context
    title Context — Market App (Login Feature)

    Person(user, "Usuário", "Pessoa com conta cadastrada no Market App")

    System(marketApp, "Market App", "Aplicação Next.js 16 que permite ao usuário autenticar-se e acessar funcionalidades protegidas (pedidos, perfil, etc.)")

    SystemDb(postgres, "PostgreSQL", "Banco de dados relacional que armazena usuários com email e hash de senha")

    Rel(user, marketApp, "Acessa via navegador", "HTTPS")
    Rel(marketApp, postgres, "Consulta usuários", "SQL / Prisma (futuro)")
```

---

## Nível 2 — Containers

*Como o sistema é dividido em unidades deployáveis e como elas se comunicam.*

```mermaid
C4Container
    title Containers — Market App (Login Feature)

    Person(user, "Usuário")

    System_Boundary(marketApp, "Market App") {
        Container(browser, "Browser (SPA Shell)", "React 19", "Renderiza o LoginForm, gerencia estado do formulário via useLoginForm hook, armazena cookie de sessão")

        Container(nextEdge, "Edge Middleware", "Next.js Edge Runtime", "Intercepta todas as requisições (exceto assets), verifica cookie JWT, redireciona ou permite acesso")

        Container(nextServer, "Next.js Server", "Node.js Runtime", "Serve Server Components (LoginPage), processa Route Handler POST /api/auth/login, executa Use Cases")

        ContainerDb(postgres, "PostgreSQL", "RDBMS", "Tabela users: id, email, password_hash, created_at, updated_at")
    }

    Rel(user, browser, "Preenche e submete formulário", "HTTPS")
    Rel(browser, nextEdge, "Toda requisição navegação", "HTTPS")
    Rel(nextEdge, nextServer, "Permite acesso ou redireciona", "interno")
    Rel(browser, nextServer, "POST /api/auth/login", "HTTPS / JSON")
    Rel(nextServer, postgres, "findByEmail()", "SQL")
    Rel(nextServer, browser, "Set-Cookie: session=JWT", "HTTPS")
```

---

## Nível 3 — Componentes

*Como o container Next.js Server é decomposto em componentes.*

```mermaid
C4Component
    title Components — Next.js Server (Login Feature)

    Container_Boundary(nextServer, "Next.js Server") {

        Component(loginPage, "LoginPage", "Server Component\napp/(auth)/login/page.tsx", "Extrai searchParams.redirect e renderiza LoginForm com redirectTo")

        Component(loginForm, "LoginForm", "Client Component\ncomponents/ui/login-form/LoginForm.tsx", "Formulário HTML acessível (aria-*, role='alert'). Puro JSX, sem lógica")

        Component(useLoginForm, "useLoginForm", "React Hook\ncomponents/ui/login-form/use-login-form.ts", "Gerencia estado do formulário, valida client-side via VOs, executa fetch para a API, navega após sucesso")

        Component(routeHandler, "POST /api/auth/login", "Route Handler\napp/api/auth/login/route.ts", "Valida payload com Zod, chama UseCase, seta cookie de sessão HttpOnly")

        Component(factory, "Root Composer", "factory.ts\napp/api/auth/login/factory.ts", "Único ponto de instanciação: cria SessionService e userRepository, injeta no UseCase")

        Component(useCase, "AuthenticateUserUseCase", "Use Case\nservices/user/authenticate-user.ts", "Orquestra: valida VOs, busca usuário via IUserRepository, verifica senha, cria sessão via ISessionService")

        Component(emailVO, "Email (Value Object)", "lib/auth/email.ts", "Valida formato de email via regex, normaliza para lowercase, imutável via Object.freeze")

        Component(passwordVO, "Password (Value Object)", "lib/auth/password.ts", "Valida comprimento (8–72 chars), compara com hash bcrypt via matches()")

        Component(sessionService, "SessionService", "lib/auth/session.ts\nimplements ISessionService", "Cria JWT com jose (HS256, 24h). Verifica e decodifica JWT. Edge Runtime compatível")

        Component(constants, "Constants", "lib/auth/constants.ts", "Todas as constantes nomeadas: SESSION_COOKIE_NAME, LOGIN_PATH, PROTECTED_ROUTES, etc.")

        Component(middleware, "Middleware", "middleware.ts\nEdge Runtime", "redirectIfAuthenticated(): redireciona usuário logado em /login. verifyProtectedAccess(): exige JWT válido em rotas protegidas")
    }

    ContainerDb(postgres, "PostgreSQL")

    Rel(loginPage, loginForm, "renderiza com redirectTo prop")
    Rel(loginForm, useLoginForm, "usa hook")
    Rel(useLoginForm, emailVO, "Email.create() para validação client-side")
    Rel(useLoginForm, passwordVO, "Password.create() para validação client-side")
    Rel(useLoginForm, routeHandler, "POST /api/auth/login")
    Rel(routeHandler, factory, "importa authenticateUserUseCase")
    Rel(factory, useCase, "instancia e injeta dependências")
    Rel(factory, sessionService, "new SessionService()")
    Rel(useCase, emailVO, "Email.create()")
    Rel(useCase, passwordVO, "Password.create()")
    Rel(useCase, sessionService, "ISessionService.create()")
    Rel(useCase, postgres, "IUserRepository.findByEmail()")
    Rel(middleware, sessionService, "SessionService.verify()")
    Rel(middleware, constants, "SESSION_COOKIE_NAME, LOGIN_PATH, PROTECTED_ROUTES")
    Rel(routeHandler, constants, "SESSION_COOKIE_NAME, SESSION_COOKIE_MAX_AGE_SECONDS")
```

---

## Nível 4 — Código (Diagrama de Classes)

*Relações entre as principais abstrações do domínio de autenticação.*

```mermaid
classDiagram
    direction TB

    class ISessionService {
        <<interface>>
        +create(payload: SessionPayload) Promise~string~
        +verify(token: string) Promise~SessionPayload~
    }

    class IUserRepository {
        <<interface>>
        +findByEmail(email: string) Promise~UserRecord | null~
    }

    class SessionService {
        -JWT_SECRET: Uint8Array
        +create(payload: SessionPayload) Promise~string~
        +verify(token: string) Promise~SessionPayload~
    }

    class AuthenticateUserUseCase {
        -userRepository: IUserRepository
        -sessionService: ISessionService
        +execute(request: AuthenticateUserRequest) Promise~AuthenticateUserResponse~
    }

    class Email {
        -value: string
        -constructor(value: string)
        +create(raw: string)$ Email
        -isValid(value: string)$ boolean
        +toString() string
        +equals(other: Email) boolean
    }

    class Password {
        -value: string
        -constructor(value: string)
        +create(raw: string)$ Password
        +matches(hash: string) Promise~boolean~
    }

    class InvalidCredentialsError {
        +code: string
        +message: string
    }

    class InvalidEmailError {
        +message: string
    }

    class InvalidPasswordError {
        +message: string
    }

    class SessionPayload {
        <<type>>
        +userId: string
        +email: string
    }

    SessionService ..|> ISessionService : implements
    AuthenticateUserUseCase --> ISessionService : depends on
    AuthenticateUserUseCase --> IUserRepository : depends on
    AuthenticateUserUseCase --> Email : creates
    AuthenticateUserUseCase --> Password : creates
    AuthenticateUserUseCase ..> InvalidCredentialsError : throws
    Email ..> InvalidEmailError : throws
    Password ..> InvalidPasswordError : throws
    SessionService ..> SessionPayload : uses
    ISessionService ..> SessionPayload : uses
```

---

## Fluxo de Dados — Login Bem-Sucedido

*Sequência detalhada atravessando todos os containers e componentes.*

```mermaid
sequenceDiagram
    actor U as Usuário
    participant F as LoginForm (Browser)
    participant H as useLoginForm (Hook)
    participant R as Route Handler
    participant FC as factory.ts
    participant UC as AuthenticateUserUseCase
    participant EVO as Email VO
    participant PVO as Password VO
    participant REPO as IUserRepository
    participant SS as SessionService

    U->>F: submit(email, senha)
    F->>H: handleSubmit()
    H->>EVO: Email.create(email) — validação client
    H->>PVO: Password.create(senha) — validação client
    H->>R: POST /api/auth/login {email, senha}
    R->>R: Zod.safeParse(body)
    R->>FC: authenticateUserUseCase.execute()
    FC-->>UC: (já instanciado com REPO + SS)
    UC->>EVO: Email.create(email)
    UC->>PVO: Password.create(senha)
    UC->>REPO: findByEmail(email)
    REPO-->>UC: { id, email, passwordHash }
    UC->>PVO: password.matches(passwordHash)
    PVO-->>UC: true
    UC->>SS: create({ userId, email })
    SS-->>UC: JWT token
    UC-->>R: { userId, email, sessionToken }
    R-->>H: 200 + Set-Cookie: session=JWT
    H->>H: router.push(redirectTo)
```

---

## Fluxo de Dados — Proteção de Rota (Middleware)

```mermaid
sequenceDiagram
    actor U as Usuário
    participant MW as Middleware (Edge)
    participant SS as SessionService
    participant NS as Next.js Server

    U->>MW: GET /dashboard
    MW->>MW: cookies.get(SESSION_COOKIE_NAME)
    alt cookie ausente
        MW-->>U: 302 → /login?redirect=/dashboard
    else cookie presente
        MW->>SS: verify(cookieValue)
        alt JWT inválido / expirado
            SS-->>MW: throws
            MW-->>U: 302 → /login?redirect=/dashboard
        else JWT válido
            SS-->>MW: SessionPayload
            MW->>NS: NextResponse.next()
            NS-->>U: 200 /dashboard
        end
    end
```
